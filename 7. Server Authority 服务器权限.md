### 什么是服务器权限？

服务器权限指服务器拥有对任何客户端都有至高无上的统御权限，可以验证、矫正、修改客户端的发送的任何指令，从而让游戏程序向期望的方式运行。

服务器权限的作用可以分为两部分，一个是对客户端的行为进行验证`validation`，一个是分配和判定游戏对象的归属权。

### 什么是行为验证？为什么要做行为验证？

行为验证指服务器会验证客户端发送的指令和参数是否合法。合法的话服务器就执行指令，否则不执行。

在绝大多数情况下，无论是游戏还是其他的应用程序，只要是基于客户端-服务器端的工作模式，都是由客户端发出行为指令和参数，然后由服务器端去执行具体行为。换句话说，客户端发出行为意愿，但具体怎么做由服务器端实现。

举个例子，客户端点击按钮，服务端执行查询。在客户端代码中，只有发出查询意愿的代码，但真正在数据库中查询的代码则是只有服务器端才有。

站在服务器的视角，服务器不能完全相信由客户端发来的指令，有以下几个原因：

1. 服务器和客户端是分离的，客户端的代码可能会被修改；
2. 客户端的输入可能是非法的，为了防止异常，服务器端需要做输入收敛；
3. 客户端的指令发送频率不符合业务逻辑（如冷却时间还未到就想再次施法）。

所以无论是客户端发来的指令还是参数，服务器都需要验证，确定是合法的。

### 什么是归属权分配？为什么要管理归属权？

归属权是`Mirror`判断服务器判断客户端是否能对某个对象执行操作的标准。

比如在RTS游戏中，客户端无法选中不属于自己的单位，更不能对敌方单位下达指令。每个对象，包括每一发炮弹都有归属权。

游戏场景中有大量的对象

### 如何让服务器做验证？

`Mirror`已经有一些自带的验证方法。

比如之前的同步变量`[SyncVar]`，客户端直接对该变量进行修改无法影响服务器和其他客户端的值。

其他的验证需要在`NetworkManager`或者其他类中的对应方法中自定义。在哪个类中定义验证并不重要，重要的是验证的方法必须是只能在服务器端运行。

例如我们做一个设置房间名称`string`的验证，要求验证客户端发来的字符串符合长度大于2且小于20的要求。我们选择在`RTSPlayer`中验证，加入验证之前的代码如下：

```c#
public class RTSPlayer
{
    // Command特性的方法只能在服务器端运行
    [Command]
    private void CmdSetDisplayName(string newRoomDisplayName)
    {
        // 通知客户端更新的名字，方法这里省略
        RpcLogNewName(newRoomDisplayName);
      
        // 在服务端中设置新名字，方法这里省略
        SetRoomDisplayName(newRoomDisplayName);
    }
}
```

加入验证代码后的方法如下：

```c#
public class RTSPlayer
{
    [Command]
    private void CmdSetDisplayName(string newRoomDisplayName)
    {
        // 验证房间名称长度，如果小于2或者大于20，直接终止执行这个方法
        if (newRoomDisplayName.Length < 2 || newRoomDisplayName.Length > 20) { return; }
      
        RpcLogNewName(newRoomDisplayName);
      
        SetRoomDisplayName(newRoomDisplayName);
    }
}
```
