# Player & Network Manager 玩家及网络管理器组件

### 什么是玩家组件？有什么用？

Player组件是挂载在一个全局的Player对象中的组件。

Player组件用于储存玩家的信息（如玩家名）、提供相关信息的数据接口（如返回玩家名）、订阅与玩家直接相关的事件（重生、死亡、金钱变动）并根据事件执行相应操作。

>> Tips:
>> 全局的Player对象不随场景的切换而销毁，应该伴随整个玩家的生命周期（使用`DontDestroyOnLoad()`方法）。

Mirror没有内置的Player组件，需要自己实现。继承`NetworkBehavior`而不是`MonoBehavior`。

### 玩家组件的生命周期和存在逻辑是什么？

当玩家客户端与服务器连接成功的时候，在客户端和服务端都生成Player对象，对象中挂载Player组件。

当玩家客户端与服务器保持连接的时候，在客户端和服务端的Player对象应该持续存在。

当玩家客户端与服务器断开连接的时候，在客户端和服务端都移除Player对象。

### 如何实现玩家组件和对象的生命周期？

在网络管理器中实现。

### 如何在编译时获得Player组件的引用？

Player组件和其挂载的对象理论上应该只在玩家连接成功的时候在服务端生成。确保连接成功时一定有Player对象（预制件，包含Player组件）。

以`RTSPlayer`组件为例，可以通过以下代码获取到组件：

```
  var player = NetworkClient.connection.identity.GetComponent<RTSPlayer>();
```

### 什么是网络管理器组件？

网络管理器组件`NetworkManager`是`Mirror`实现联机数据交换的核心。无论是主机还是客户端，都需要这个组件。

### 网络管理利器能实现哪些功能？

五个主要部分（授权部分暂时不讨论），分别是：

#### 1. 基础配置

可以设置是否在切换场景时保留该对象、是否在线上和离线场景切换时保留该对象、是否在后台运行、是否当服务器建立好后自动开始服务器、是否启用批量信息传递（在LateUpdate后发送）等等。

还可以设置服务器更新频率。比如建议建立CS这种游戏的服务器使用60HZ来降低延迟；WOW这种游戏使用30HZ来减少运算；EVE这种慢节奏游戏使用10HZ。

#### 2. 场景管理

管理两个对象，分别是ref一个离线场景和一个线上场景。

当服务器或客户端停止运行时自动切换到这里事先ref的离线场景；

当服务器启动时会自动切换到这里ref的线上场景，当客户端连接上服务器后，会接收到一个场景消息并加载与服务器相同的场景。

#### 3. 网络数据传输配置

定义和管理数据传输组件。可以使用Mirror内置的组件如`Kcp Transport`或者其他三方或自制的组件。

这个部分还包括设置客户端连接服务器的地址（可以在代码层更改，在组件中留默认localhost就行）、最大连接数、是否自动踢掉长时间无回应的客户端等等。

#### 4. 玩家对象配置 

定义和管理玩家对象组件（就是上文提到的`Player`组件）。

可以在这个部分设置是否在场景切换后自动生成玩家组件、决定玩家重生地点顺序等等。

#### 5. 可重生预制件注册

多人游戏中，所有要在服务器上重生的预制件都要在这里注册，服务器不会实例化未注册预制件。添加预制件进列表中即可。

### 网络管理器是否可以自定义？

可以，而且一定要自定义。如果把多人游戏比作一艘船，那么`Mirror`提供的`NetworkManager`只有龙骨。所有自定义的数据、行为、事件都需要自己定义，且集中添加到自定义的网络管理器中。

新建一个脚本，通过继承`Mirror`自带的管理器即可添加自己的内容。

### 一般定制的网络管理器都添加哪些内容？

#### 1. 添加游戏对象Reference

在管理器中通过钩子函数生成一些游戏中需要的对象。

比如RTS游戏中，游戏场景开始需要为每个玩家生成一个主基地对象，其执行语句可以写在这个管理器中，如下：

```c#
public class RTSNetworkManager : NetworkManager
{
    [SerializeField]
    private GameObject mainBasePrefab = null;
    
    public override void OnServerSceneChanged(string sceneName)
    {
        if (SceneManager.GetActiveScene().name.StartsWith("Scene_Map"))
        {
            var gameOverHandlerInstance = Instantiate(gameOverHandlerPrefab);

            NetworkServer.Spawn(gameOverHandlerInstance.gameObject);

            foreach(var p in players)
            {
                var baseInstance = Instantiate(mainBasePrefab, GetStartPosition().position, Quaternion.identity);

                NetworkServer.Spawn(baseInstance, p.connectionToClient);
            }
        }
    }
}
```

再比如，基本所有游戏都需要一个游戏结束界面，也就是说需要在服务器开始时生成一个包含结束界面的对象，可以使用如下代码：

```c#
public class RTSNetworkManager : NetworkManager
{
    [SerializeField]
    private GameOverHandler gameOverHandlerPrefab = null;
    
    public override void OnStartServer()
    {
        var gameOverHandlerInstance = Instantiate(gameOverHandlerPrefab);

        NetworkServer.Spawn(gameOverHandlerInstance.gameObject);
    }
}
```

#### 2. 添加与服务器状态有关的事件

游戏程序很大，通常一个字段的信息会是很多子系统的依赖。比如玩家的金钱数量，会在主界面、商店页面、背包页面等地方显示，当金钱数量变化时，每个地方都需要变化。一一去更新太麻烦，还可能会漏掉。所以使用事件系统来做这些字段行为更新。

在`NetworkManager`中添加的事件自然就是与服务器开关离合的变化相关的事件，比如可以有这些：

```c#
public class RTSNetworkManager : NetworkManager
{
    public static event Action ClientOnConnected; // 当客户端连接上时触发的事件
    public static event Action ClientOnDisconnected;  // 当客户端丢失链接时触发的事件
    public static event Action ClientOnStopped; // 当客户端停止时触发的事件
    public static event Action OnPlayerNumberChanged; // 当玩家人数变化时触发的事件
}
```

在相关勾子函数中唤醒这些事件即可开始监听，如：

```c#
public class RTSNetworkManager : NetworkManager
{
    public static event Action ClientOnConnected; // 当客户端连接上时触发的事件
    
    // 在客户端调用，当客户端连接时的钩子函数
    public override void OnClientConnect(NetworkConnection conn)
    {
        base.OnClientConnect(conn);
        Debug.Log("客户端连接成功");
        ClientOnConnected?.Invoke();  // 唤醒事件监听
    }
}
```

#### 3. 其他辅助字段

比如在玩家人数变化事件中需要有地方储存玩家的实时人数，可以声明一个玩家列表，如下：

```c#
public class RTSNetworkManager : NetworkManager
{
    public static event Action OnPlayerNumberChanged;
    public List<RTSPlayer> players { get; } = new List<RTSPlayer>();
    
    // 在服务端调用，当有客户端断开连接时的钩子函数
    public override void OnServerDisconnect(NetworkConnection conn)
    {
        // 获得断开连接的玩家ref
        var player = conn.identity.GetComponent<RTSPlayer>();
        
        // 在玩家列表中移除该玩家
        players.Remove(player);
        
        // 唤醒玩家数量变化事件监听
        OnPlayerNumberChanged?.Invoke();

        base.OnServerDisconnect(conn);
    }
}
```

### 网络管理器有哪些钩子函数？他们的生命周期又是什么？

